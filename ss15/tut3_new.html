<!DOCTYPE html>
<html>
<head>
  <title></title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="../slides/theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="../slides/theme/css/phone.css">
  <base target="_blank">
  <script src="../slides/js/require-1.0.8.min.js"></script>
  <script type="text/javascript">
    var SLIDE_CONFIG = {
      settings: {
        title: "Tutorium #2",
        subtitle: "Softwareentwicklung Praktikum",
        fonts: [
          'Open Sans:regular,semibold,italic,italicsemibold',
          'Source Code Pro'
        ]
      }
    };
    require([
         '../slides/js/order!../slides/js/modernizr.custom.45394',
         '../slides/js/order!../slides/js/prettify/prettify',
         '../slides/js/order!../slides/js/hammer',
         '../slides/js/order!../slides/js/slide-controller',
         '../slides/js/order!../slides/js/slide-deck'],
         function(someModule) {}
    );
  </script>
  <style type="text/css">
    slides > slide:not(.nobackground):before {
      background: none;
      display: none;
    }
    slides > slide {
      color: #222;
    }
    h2 {
      color: #ee1952;
    }
    strong {
      color: #ee1952;
      font-weight: bold;
    }
    dt {
      margin: .4em 0 .2em 0;
    }
    dd {
      margin: .2em 0 .2em 1.5em;
    }
    pre {
      margin: .4em 0 .4em 0;
      left: 0;
      width: 100%;
      padding: .4em .5em;
    }
    div.left {
      float: left;
      width: 48%;
    }
    div.right {
      margin-left: 52%;
      width: 48%;
    }
    span.src {
      font-family: monospace;
      background: #eee;
      border: 1px solid #ccc;
      padding: 1px 2px;
    }
  </style>
</head>
<body id="tugraz" style="opacity: 0">

<slides class="layout-widescreen">
  <slide class="title-slide segue nobackground">
    <aside class="gdbar"><img src="images/tugraz128.png"></aside>
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p data-config-presenter><!-- populated from slide_config.json --></p>
    </hgroup>
  </slide>
  
       <slide><hgroup>
        <h2>Ablauf des Tutoriums</h2></hgroup><article>
        <ul class="compact">
         <li>Häufige Fehler</li>
         <li>File IO</li>
         <li>Operator Overloading</li>
         <li>Casting</li>
         <li>Exceptions</li>
         <li>Ressourcenverwaltung</li>
         <li>Auto-Pointer</li>
         <li>Templates</li>
         <li>Ass3</li>
        </ul>
     </article></slide>

     <slide><hgroup>
       <h2>H&auml;ufigste Fehler in Ass2</h2></hgroup><article>
       <ul>
         <li>Nicht genügend getestet (z.B. "next 1a")</li>
         <li>Messages nicht 1 zu 1 aus der Angabe kopiert</li>
         <li>If - ElseIf - Else zum matchen von Commands</li>
         <li>Doppelter Code (z.B. bei Next)</li>
         <li>Zu tiefe Verschachtelungen</li>
         <li>Speicherlöcher, Valgrindfehler</li>
         <li>Codingstandard</li>
       </ul>
     </article></slide>
     
     <slide><hgroup>
       <h2>H&auml;ufige Fehler, die viele Punkte kosten</h2></hgroup><article>
       <center><br /><img src="images/segfaults.jpg" width="350"/></center>
       <ul>
         <li>Valgrind Warnings</li>
         <li>unn&ouml;tiges <span class="src">this</span></li>
         <li>Doppelter Code</li>
         <li>C statt C++ Casts</li>
         <li>Codingstandard</li>
       </ul>
     </article></slide>


     <slide><hgroup>
      <h2>File-IO - File öffnen</h2></hgroup><article>
    <p>Bin&auml;rdatei zum Schreiben &ouml;ffnen</p>
    <pre class="compact">
  #include &lt;fstream>
  std::ofstream file("tut4.bin",
    std::ios::out | std::ios::trunc | std::ios::binary);
  if (!file.is_open()) 
  {
    std::cerr &lt;&lt; "cannot open file" &lt;&lt; std::endl;
  } else file.close(); </pre>
  <p>Bin&auml;rdatei zum Lesen &ouml;ffnen</p>
    <pre class="compact">
  std::ifstream input("tut4.bin", std::ios::in | std::ios::binary);
  if (!input.is_open()) 
  {
    std::cerr &lt;&lt; "cannot open file" &lt;&lt; std::endl;
  } else input.close();</pre>
     </article></slide>
   <slide><hgroup>
   <h2>File-IO - Schreiben</h2></hgroup><article>
<pre class="compact">
// schreibe "SEPRISK\0" in Datei
file &lt;&lt; "SEPRISK";
file &lt;&lt; '\0';
// schreibe Zahl 7 als Bin&auml;rwert -> in char speichern 
// und dann in Datei schreiben
char num = 7;
file &lt;&lt; num;
// schreibe Zahl 7 als Ziffer ('7') -> wenn Zahl 
// in int gespeichert ist
int num2 = 7;
file &lt;&lt; num2;
// schreibe C-String mit Nullbyte
char* str = "Hallo Welt";
file &lt;&lt; str &lt;&lt; '\0';
</pre>
<br />
<img src="images/homer2.gif" width="100px" style="float: left;"/>
     <div style="border: 1px solid #ccc; border-radius: 16px; padding: 8px; float: left; margin-left: 20px; width: 600px; background-color: #fcfcfc;">
     Dateien können behandelt werden wie <span class="src">std::cout</span> und <span class="src">std::cin</span>
     </div>
   </article></slide>
   
   <slide><hgroup>
   <h2> File-IO - Lesen
   </h2></hgroup><article>
   <pre>
  // lese C-String Zeichenweise bis Nullbyte zur&uuml;ck
  char c;
  while((input >> c) &amp;&amp; c != 0) {
   std::cout &lt;&lt; c; 
  }
  std::cout &lt;&lt; std::endl;
  // lese Bin&auml;rwert 7 zur&uuml;ck (und zeige als char und integer an)
  char y;
  input >> y;
  std::cout &lt;&lt; y &lt;&lt; " = " &lt;&lt; static_cast&lt;int>(y) &lt;&lt; std::endl;
  // lese Zahl 7 als Ziffer ('7') zur&uuml;ck
  int x;
  input >> x;
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  </pre>
 </article></slide>

     <slide><hgroup>
      <h2>Operator Overloading</h2></hgroup><article>
      <ul>
       <li>&Uuml;berschreibt die Operatoren (<span class="src">==</span>, <span class="src">+</span>, <span class="src">-</span>, <span class="src">*</span>, <span class="src">/</span>, ...) f&uuml;r die eigene Klasse</li>
       <li>Syntax: (<span class="src">@</span> steht f&uuml;r den Operator)
<pre class="compact">
return_type operator@(argumente)
{
    [...]
}
</pre></li>
      <li>Kann als Member-Funktion oder als <span class="src">friend</span> deklariert werden</li>
      <li>Sollte sparsam verwendet werden und nur wenn es eindeutig ist</li>
      </ul>
     </article></slide>
     
     <slide><hgroup>
      <h2>Operator Overloading - Beispiel (als Member)</h2></hgroup><article>
<pre class="compact" style="font-size: .62em; line-height: 1.22em; width: 90%; margin: 0.5em auto;">
class Complex
{
private:
  float real_part_;
  float imaginary_part_;
  
public:
    bool operator==(const Complex &amp;c) const
    {
        return ( c.real_part_ == real_part_ &amp;&amp;
                (c.imaginary_part_ == imaginary_part_) );
    }
    
    Complex operator+(const Complex&amp; right)
    {
      Complex result;
      result.setImaginary(imaginary_part_ + right.getImaginary());
      result.setReal(real_part_ + right.getReal());
      return result;
    }
    
    [...]
};
</pre>
     </article></slide>
     
     <slide><hgroup>
        <h2>Casts in C++</h2></hgroup><article>

        <dl class="expl">
          <dt><span class="src">static_cast</span></dt>
          <dd>Funktioniert wie das von C bekannte Casting <span class="src">(typ)variable</span>. Funktioniert nur, wenn der Compiler eine Regel zum Casten kennt.
            <pre class="compact">int a = 16, b = 9;
float ratio = static_cast&lt;float&gt;(a) / b;</pre></dd>
          <dt><span class="src">const_cast</span></dt>
          <dd>Nur zum Hinzuf&uuml;gen oder Entfernen <span class="meta">(gefährlich)</span>
            des <span class="src">const</span>
            Keywords.</dd>
          <dt><span class="src">dynamic_cast</span></dt>
          <dd>Casts innerhalb einer Klassenhierarchie von polymorphen Klassen. Aufw&auml;ndige Type-Checks zur Laufzeit.
                  <pre class="compact">// Cast von *CD in *MusicCD
MusicCD *charts = dynamic_cast&lt;*MusicCD&gt;(cd1);</pre></dd>
          <dt><span class="src">reinterpret_cast</span></dt>
          <dd style="width: 75%;">Keine Konvertierung, Daten werden ohne &Auml;nderung als neuer Datentyp interpretiert,
            plattformabh&auml;ngig, sollte nur bei hardwarenaher Programmierung verwendet werden.</dd>
        </dl>
     </article></slide>
     
     <slide><hgroup>
      <h2><span class="src">static_cast</span> verlustfreie Regeln</h2></hgroup><article>
      <center><img src="images/casts.png" width="700px" style="padding-top: 8px;" /></center>
      <br />
      <img src="images/homer2.gif" width="100px" style="float: left;"/>
     <div style="border: 1px solid #ccc; border-radius: 16px; padding: 8px; float: left; margin-left: 20px; width: 600px; background-color: #fcfcfc;">
     Castings sind nur dann ohne Datenverlust, wenn auf einen gr&ouml;&szlig;eren Datentyp gecastet wird.
     </div>
     </article></slide>

     <slide><hgroup>
      <h2>Exceptions</h2></hgroup><article>
      <br />Grundlegendes Konstrukt f&uuml;r Exceptions
<pre>
try
{
  someFunction() // k&ouml;nnte eine Exception werfen...
  [...]
  throw(e); // ...oder manuelles Werfen einer Exception
}
catch(MyException&amp; e1)
{
  // fange Exception vom Typ MyException
}
catch(std::exception&amp; e)
{
  // fange alles, was vom Typ std::exception abgeleitet ist, 
  // und noch nicht gefangen wurde
}
</pre>
     </article></slide>
     
     <slide><hgroup>
      <h2>Exceptions</h2></hgroup><article>
      <br />
      N&uuml;tzlich, aber nicht &uuml;bertreiben &rarr; <strong>Formale Fehlerquellen</strong>
      <ul>
      <li>Kontrollfluss durch Exceptions</li>
      <li>Silent Catch von Exceptions</li>
      <li>Wurf einer Nicht-std::exception-Unterklasse</li>
      <li>Im Destruktor dürfen keine Exceptions geworfen werden</li>
      </ul>
      <br />
      Also immer
<pre class="compact">
 class MyException : public std::exception {
   [...]
 };
</pre>
     </article></slide>
     
     <slide><hgroup>
      <h2>Exceptions - Beispiel</h2></hgroup><article>
      <ul>
      <li><pre class="compact" style="display: inline;">virtual const char* what() const</pre> sollte eine Fehlerbeschreibung liefern (als <span class="src">const char*</span>)</li>
      </ul>
      <pre class="compact" style="font-size:0.60em; line-height:1.2em; margin: 0.5em auto; width: 75%;">
#include &lt;exception>
class brick : public std::exception {
  virtual const char* what() const throw()
  {
    return "Achtung Ziegel!\n";
  }
};

int main ()
{
  try
  {
    throw brick();
  } catch (std::exception&amp; ex)
  {
    std::cout &lt;&lt; ex.what();
  }
  return 0;
} </pre>
     </article></slide>
   
    <slide><hgroup>
     <h2>Neu zu beachten: Out of Memory!</h2></hgroup><article>
<pre>
int main () 
{
  try
  {
    int* myarray = new int[10000];
  }
  catch (std::bad_alloc& ba)
  {
    std::cout << "Out of Mana!" << std::endl;
  }
  return 0;
}
</pre>
     </article></slide>

          <slide><hgroup>
     <h2>Neu zu beachten: Out of Memory!</h2></hgroup><article>
<p style="font-size:20px;"><strong>In jedem Fall muss aller Speicher wieder freigegeben werden!</strong></p>

<pre class="compact" style="font-size: 17px; line-height: 1.2em;">
...
try
{
  NextCommand* next = new NextCommand("next");  
}
catch (std::bad_alloc& ba)
{
  std::cout << "Out of Mana!" << std::endl;
  return 0;
}
try
{
  ShowCommand* show = new ŚhowCommand("show");  
}
catch (std::bad_alloc& ba)
{
  delete next;
  std::cout << "Out of Mana!" << std::endl;
  return 0;
}
...
</pre>
<p style="font-size:22px;" align="center"><strong>Aber geht das nicht besser???</strong></p>
     </article></slide>

     <slide><hgroup>
     <h2>Besser:</h2></hgroup><article>
     <ul>
     <li>Smart Pointer verwenden!</li>
     <li>Variablen sofort nach dem "new" Aufruf in eine Klassen-Member-Variable Speichern, die vom Destruktor wieder freigegeben wird.</li>
     <li>RAII</li>
     </ul>
     <p>-> Es reicht bad alloc in der Main zu fangen.</p>
     <p><strong>Außer: Exceptions im Konstruktor!</strong></p>
     </article></slide>

     <slide><hgroup>
     <h2><strong>Achtung</strong>: Exception im Konstruktor</h2></hgroup><article>
     <ul>
     <li>Wird im Konstruktor eine Exception geworfen, ist das Objekt nicht erstellt, und auch der Destruktor wird nicht aufgerufen.</li>
     </ul>
<pre class="compact" style="font-size: 0.55em; line-height: 1.22em; width: 75%; margin: 1em auto;">
#include &lt;memory>
#include &lt;iostream>
#include &lt;vector>
class Foo {
private:
    std::vector&lt;int*> list;
public:
    Foo() {
        list.push_back(new int);
        list.push_back(new int);
        throw 1;
    }
    
    ~Foo() {
      for(auto it : list) {
          delete it;
      }
    }
};
int main() {
    Foo f;
    return 0;
}</pre>
     </article></slide>

     
     
     
     <slide><hgroup>
      <h2>Resource Acquisition Is Initialization (RAII)</h2></hgroup><article>
      <ul>
        <li>Konzept zur Verwaltung von Ressourcen</li>
        <li>Automatische Freigabe beim Verlassen des Scopes</li>
        <li>Kann f&uuml;r Handles (z.B. Dateien), Locks und Speichern verwendet werden</li>
        <li>Erleichtert das Schreiben von Exception-sicheren Programmen</li>
      </ul>
      <img src="images/raii.png" />
     </article></slide>
     
     <slide><hgroup>
      <h2>Kein RAII - Beispiel</h2></hgroup><article>
<pre class="compact" style="font-size: 0.55em; line-height: 1.22em; width: 65%; margin: 1em auto;">
int median(int* numbers, int count) {
  int* data = new int[count];
  std::memcpy(data, numbers, count * sizeof(int));
  // error handling
  if(numbers == NULL) {
    delete[] data; // &lt;---
    return 0;
  }
  if(count == 0) {
    delete[] data; // &lt;---
    return 0;
  }
  if(count == 1) {
    delete[] data; // &lt;---
    return *numbers;
  }
  // sort
  if(mySortFunction(data, count) == false) {
    delete[] data; // &lt;---
    return 0;
  }
  // return median
  int result = data[count / 2];
  delete[] data; // &lt;---
  return result;  
}
</pre>

     </article></slide>
     
     <slide><hgroup>
       <h2>RAII - Beispiel</h2></hgroup><article>
<pre class="compact" style="float: left; width: 47%; font-size: 0.6em; line-height: 1.3em; margin-right: 16px; margin: 1em;">
int median(int* numbers, int count)
{
  Data data(count);
  data.setData(numbers, count);
  // error handling
  if(numbers == NULL)
    return 0;
  if(count == 0) 
    return 0;
  if(count == 1)
    return *numbers;
    
  // sort
  if(mySortFunction(data.getData(),
       count) == false) 
    return 0;
  
  return data.getData()[count / 2];  
}
</pre>
<pre class="compact" style="float: left; width: 37%; margin: 1em; font-size: 0.6em; line-height: 1.3em;">
class Data 
{
private:
  int* data_;
public:
  Data(int count) { 
    data_ = new int[count]; 
  }
  int* getData() const {
    return data_; 
  }
  void setData(int* data, 
               int count) 
  {
    std::memcpy(data_, data, 
      count * sizeof(int));             
  }
  ~Data() { 
    delete[] data_; 
  }
};
</pre>
     </article></slide>

     <slide><hgroup>
      <h2>Smart Pointer <img src="images/newflag.jpg" style="vertical-align: middle;" /></h2></hgroup><article>
      <ul>
       <li>Helfen beim Verwalten von <u>dynamischem</u> Speicher</li>
       <li>Zugriff wie &uuml;ber einen normalen Pointer</li>
       <li>Im Header <span class="src">&lt;memory></span> zu finden (<a href="http://en.cppreference.com/w/cpp/memory">C++ Referenz</a>)</li>
       <li>Syntax: <pre class="compact">std::unique_ptr&lt;typ> pointer(speicher);</pre></li>
      </ul>
      <br /><br />
      <img src="images/homer2.gif" width="100px" style="float: left;"/>
     <div style="border: 1px solid #ccc; border-radius: 16px; padding: 8px; float: left; margin-left: 20px; width: 600px; background-color: #fcfcfc;">
     "Stirbt" der Smart-Pointer, wird der reservierte Speicher (durch <span class="src">delete</span>) freigegeben.
     </div>
     </article></slide>

     <slide><hgroup>
      <h2>Smart Pointer - Beispiel <img src="images/newflag.jpg" style="vertical-align: middle;" /></h2></hgroup><article>
      <pre class="compact" style="font-size: 0.6em; line-height: 1.15em; width: 80%; margin: 1em auto;">
#include &lt;iostream>
#include &lt;memory>

class Foo {
public:
  void bar() {
    std::cout  &lt;&lt; "foobar" &lt;&lt; std::endl;
  }
};

std::unique_ptr&lt;Foo> createFoo() {
  Foo* bar = new Foo();
  return std::unique_ptr&lt;Foo>(bar);
}

int main() {
    std::unique_ptr&lt;Foo> ptr = createFoo();
    
    std::vector&lt;std::unique_ptr&lt;Foo>> foos;
    
    foos.push_back(std::unique_ptr&lt;Foo>(new Foo()));
    foos.push_back(std::unique_ptr&lt;Foo>(new Foo()));
    foos.push_back(std::unique_ptr&lt;Foo>(new Foo()));
    
    ptr->bar();
}</pre>
     </article></slide>
     
     <slide><hgroup>
      <h2>Templates</h2></hgroup><article>
      <ul>
       <li>Erlauben es, generische Funktionen zu schreiben</li>
       <li>Werden in der STL ausgiebig verwendet</li>
       <li>Es gibt Funktions- und Klassentemplates</li>
       <li>Deklarations-Syntax: <pre class="compact">template &lt;typename identifier> function_declaration;</pre></li>
       <li>Aufrufs-Syntax: <pre class="compact">function&lt;argument_type>(arguments);</pre> bzw. <pre class="compact">classname&lt;class_type>(constructor_values);</pre></li>
      </ul>
     </article></slide>
     
     <slide><hgroup>
      <h2>Templates - Beispiel (Funktionstemplate)</h2></hgroup><article>
      <br />
<pre class="compact">
template &lt;typename Type>
Type max(Type a, Type b) 
{
    if(a > b) return a;
    else return b;
}
</pre>
<pre class="compact">
int main()
{
  // ruft max&lt;int> auf (wird an Argumenten erkannt)
  std::cout &lt;&lt; max(3, 7) &lt;&lt; std::endl;
  // ruft max&lt;double> (wird an Argumenten erkannt)
  std::cout &lt;&lt; max(3.0, 7.0) &lt;&lt; std::endl;
  // Argumente nicht eindeutig, Typ muss angegeben werden (&lt;double>)
  std::cout &lt;&lt; max&lt;double>(3, 7.0) &lt;&lt; std::endl;
  return 0;
}
</pre>
     </article></slide>
     
     <slide><hgroup>
      <h2>Templates - Beispiel (Klassentemplate)</h2></hgroup><article>
<pre class="compact">
template &lt;typename T>
class Math {
public:
  T getMin(T x1, T x2) {
    if(x1 &lt; x2) return x1;
    else return x2;
  }
  
  T getMax(T x1, T x2) {
    if(x1 > x2) return x1;
    else return x2;
  }
};
</pre>
<pre class="compact" style="font-size: .62em; line-height: 1.3em;">
int main() {
  Math&lt;int> int_math;
  Math&lt;std::string> str_math;
  
  std::cout &lt;&lt; "max(2, 4): " &lt;&lt; int_math.getMax(2, 4) &lt;&lt; std::endl;
  std::cout &lt;&lt; "min(\"abc\", \"bcd\"): " 
    &lt;&lt; str_math.getMin("abc", "bcd") &lt;&lt; std::endl;
}
</pre>
     </article></slide>

     
   <slide><hgroup>
     <h2>Assignment 3</h2></hgroup><article>
         <br />
     <img src="images/towerdefense.png" width="729" />
     <br /><br /><a href="http://towersep.appspot.com/">http://towersep.appspot.com/</a>
    </article></slide>

         
    
    
     <slide><hgroup>
     <h2>&Uuml;bernommene Befehle</h2></hgroup><article>
     <br />
     
         <div class="command">
          <div class="title">show</div>
          <div class="text">Ausgabe von Spielfeld, Kapital und HP</div>
         </div>

         <div class="command">
          <div class="title">next</div>
          <div class="text">Runde beenden bzw. <em>n</em> Runden vorspulen</div>
         </div>

         <div class="command">
          <div class="title">quit</div>
          <div class="text">Beendet das Programm</div>
         </div>

     
    </article></slide>
     
     <slide><hgroup>
     <h2>Neue Befehle</h2></hgroup><article>
     <br />
     <div class="command">
      <div class="title">stats</div>
      <div class="text">Zeigt Spielstatistiken an</div>
     </div>
     
     <div class="command">
      <div class="title">shop</div>
      <div class="text">Turm-Shop aufrufen</div>
     </div>

     <div class="command">
      <div class="title">buy</div>
      <div class="text">Turm kaufen und errichten</div>
     </div>

     <div class="command">
      <div class="title">show target</div>
      <div class="text">Zeigt an, was sich auf einem Feld befindet</div>
     </div>

     <div class="command">
      <div class="title">upgrade (Bonus)</div>
      <div class="text"><strong>Bonus</strong>: Turm upgraden auf besseren Turm</div>
     </div>

    </article></slide>
        <slide><hgroup>
     <h2>Ratio</h2></hgroup><article>
         <br />
          Rationale Zahl, bestehend aus  <strong>zwei teilerfremden Ganzzahlen.</strong>
    <pre class="compact" style="font-size: .62em; line-height: 1.1em;">
int main() {
  Ratio ratio_1(7,3);
  Ratio ratio_2(3,2);
  std::cout << "Ratios: " << std::endl;
  std::cout << ratio_1 << std::endl;
  std::cout << ratio_2 << std::endl;

  Ratio sum = ratio_1 + ratio_2;

  std::cout << "Sum:" << std::endl;
  std::cout << sum << std::endl;

  sum = sum - 2;
  std::cout << "Sum - 2:" << std::endl;
  std::cout << sum << std::endl;
  if(sum > 1)
    std::cout << "Ratio: " << sum << " is > 1" << std::endl;
  else
    std::cout << "Ratio: " << sum << " is < 1" << std::endl;
}
</pre>
    </article></slide>
     <slide><hgroup>
     <h2>Ratio</h2></hgroup><article>
         <br />
          Ausgabe
    <div class="console">
Ratios: <br />
7 / 3<br />
3 / 2<br />
Sum:<br />
23 / 6<br />
Sum - 2:<br />
11 / 6<br />
Ratio: 11 / 6 is > 1<br />
</div>
    </article></slide>
    <slide><hgroup>
     <h2>SVG</h2></hgroup><article>
      <ul>
       <li>Scalable Vector Graphics</li>
       <li>Bild wird durch Vektoren beschrieben</li>
       <li>Beschreibung als XML</li>
       <li>Beliebig skalierbar</li>
      </ul>
      <center>
      <img src="images/vector_raster.png" height="320" />
      </center>
    </article></slide>
    
    
    <slide><hgroup>
     <h2>SVG - Aufbau</h2></hgroup><article>
<br />
Header
<pre>
&lt;svg xmlns="http://www.w3.org/2000/svg" 
  xmlns:xlink="http://www.w3.org/1999/xlink">  
</pre>

Objekte
<pre>
&lt;image x="0" y="0" width="1016px" height="638px" 
  xlink:href="base.svg"> &lt;/image>
[...]
</pre>

Footer
<pre>
&lt;/svg>
</pre>
     
    </article></slide>
    
    
    <slide><hgroup>
     <h2>SVG - Einfache Objekte</h2></hgroup><article>
     <ul>
      <li>Text: <pre class="compact" >&lt;text x="10" y="490">Player1&lt;/text></pre></li>
      <li>Kreis: <pre class="compact" >&lt;circle cx="64" cy="90" r="14" stroke="black" 
   stroke-width="2" fill="red"/></li>
      <li>Rechteck: <pre class="compact">&lt;rect x="0" y="448" width="152" height="52" fill="green" /></li>
      <li>Eingebettete Bilder: <pre class="compact">&lt;image x="0" y="0" width="1016px" height="638px"
  xlink:href="base.png">&lt;/image></pre></li>
     </ul>
    </article></slide>
    

     <slide><hgroup>
        <h2>Ablauf des Tutoriums</h2></hgroup><article>
        <ul class="compact">
         <li>Pointer &amp; Referenzen</li>
         <li>const, static und virtual</li>
         <li>Vererbung</li>
         <li>Abstrakte Klassen</li>
         <li>C++11</li>
         <li>Command Pattern</li>
         <li>Ass2</li>
        </ul>
     </article></slide>


    <slide><hgroup>
     <h2>Pointer &amp; Referenzen</h2></hgroup><article>
     <table>
      <tr><td style="border: 0px;">
<pre class="compact" style="font-size: .55em; line-height: 1.2em;">
#include &lt;iostream>

void funcValue(int x, int val) {
  x = val;
}

int main() {
  int v = 3;
  funcValue(v, 4);
  std::cout &lt;&lt; v &lt;&lt; std::endl;
}
</pre>
      </td><td style="border: 0px;">
<pre class="compact"  style="font-size: .55em; line-height: 1.2em;">
#include &lt;iostream>

void funcReference(int&amp; x, int val) {
  x = val;
}

int main() {
  int v = 3;
  funcReference(v, 4);
  std::cout &lt;&lt; v &lt;&lt; std::endl;
}
</pre>
      </td></tr><tr>
      <td style="border: 0px;">
<pre class="compact" style="font-size: .55em; line-height: 1.2em;">
#include &lt;iostream>

void funcPointer(int* x, int val) {
  *x = val;
}

int main() {
  int v = 3;
  funcPointer(&amp;v, 4);
  std::cout &lt;&lt; v &lt;&lt; std::endl;
}
</pre>
      </td><td style="border: 0px;">
      <ul style="font-size: 80%;">
       <li>Referenzen k&ouml;nnen <em>nicht</em> <span class="src">NULL</span> sein, Pointer schon</li>
       <li>Referenzen k&ouml;nnen wie normale Variablen verwendet werden</li>
       <li>Bei Referenzen und Pointern wird nur die Adresse &uuml;bergeben, sonst wird kopiert</li>
      </ul>
      </td></tr>
     </table>
    </article></slide>

         
         
    <slide><hgroup>
     <h2><span class="src">const</span> Schl&uuml;sselwort</h2></hgroup><article>
     <ul>
      <li>F&uuml;r Konstanten
<pre class="compact">
 const int ANSWER_TO_EVERYTHING = 42;
</pre>
      <li>F&uuml;r Pointer
      <ul style="padding-top: 12px;">
       <li>Pointer auf Konstante: <pre style="display: inline;">const int * some_pointer;</pre></li>
       <li>Alternativ auch: <pre style="display: inline;">int const * some_pointer;</pre></li>
       <li>Konstanter Pointer auf Variable: <pre style="display: inline;">int * const SOME_POINTER;</pre></li>
       <li>Konstanter Pointer auf Konstante: <pre style="display: inline;">int const * const SOME_POINTER;</pre></li>
      </ul>
     </ul>
     <br />
     <img src="images/homer2.gif" width="100px" style="float: left;"/>
     <div style="border: 1px solid #ccc; border-radius: 16px; padding: 8px; float: left; margin-left: 20px; width: 600px; background-color: #fcfcfc;">
     <span class="src">const</span> bezieht sich immer auf den linken Nachbarn. Gibt es keinen, dann auf den rechten Nachbarn.
     </div>
    </article></slide>
 
   
    <slide><hgroup>
     <h2><span class="src">const</span> Schl&uuml;sselwort</h2></hgroup><article>
     <ul>
      <li>F&uuml;r Funktionsparamter
<pre class="compact">
void doSomething(const char * str)
{
[...]
}
</pre>
Funktion garantiert dem Aufrufer, dass sie den Wert, auf den der Pointer zeigt, nicht &auml;ndern wird (kann).</li>
      <li style="margin-top: 28px;">F&uuml;r Methoden
<pre class="compact">
class SomeClass {
  void doSomething() const;
};
</pre>
Die Methode kann keine Membervariablen ver&auml;ndern. 

     </ul>
    </article></slide>

    <slide><hgroup>
     <h2><span class="src">const</span> Schl&uuml;sselwort</h2></hgroup><article>
     <br /><br />
     <h3 style="font-size: 120%;">...und was macht das?</h3>
     <br />
<pre>
int const * const doSomething(const int * const &amp; parameter) const;
</pre>
    <img src="images/cereal_guy.png" width="450px" style="float: right;" />
    </article></slide>
 
    <slide><hgroup>
     <h2><span class="src">static</span> Schl&uuml;sselwort</h2></hgroup><article>
     <br />
     <span style="font-size: 90%;">
     Statische Attribute und Methoden werden <strong>pro Klasse nur einmal</strong> angelegt, 
     statt wie sonst f&uuml;r jede Instanz.
     </span><br />
     <span style="font-size: 80%; display: block; margin-top: 16px; margin-bottom: 16px;">
     Zugriff &uuml;ber <span class="src">Klassenname::funktion()</span> bzw. <span class="src">Klassenname::variable</span>
     </span>
<pre class="compact"  style="font-size: .55em; line-height: 1.25em; width: 75%; margin: 1em auto;">
class Product 
{
  private:
    static int count_;
  public:
    Product() { count_++; }
    ~Product() { count_--; }
    static int getProductsCount() { return count_; }
};

int Product::count_ = 0;

int main() 
{
  std::cout &lt;&lt; Product::getProductsCount() &lt;&lt; std::endl;
  Product p1;
  std::cout &lt;&lt; Product::getProductsCount() &lt;&lt; std::endl;
} 
</pre>
</article></slide>
    
    <slide><hgroup>
     <h2>Vererbung</h2></hgroup><article>
     <table style="margin:0px;padding:0px;"><tr><td style="border: 0px;">
<pre class="compact" style="font-size: .55em; line-height: 1.25em; ">
class CD 
{
private:
  int capacity_;
  string title_;
  
public:
  CD(string title, int size) 
   : capacity_(size), title_(title) {}
  
  int getCapacity() { 
    return capacity_; 
  }
  
  void printTitle() { 
    cout &lt;&lt; title_ &lt;&lt; endl; 
  }
};
</pre>
</td><td style="border: 0px;">
<pre class="compact" style="font-size: .55em; line-height: 1.25em;">
class MusicCD : public CD 
{
private:
  int tracks_;

public:
  MusicCD(string name, int tracks) 
   : CD(name, 700), tracks_(tracks)
  {}
  
  int getCapacity() { 
    return tracks_; 
  }
  
  void play() {
    cout &lt;&lt; "lalalala" &lt;&lt; endl;
  }
};
</pre>
</td></tr>
<tr>
<td style="border: 0px; ">
<pre class="compact" style="font-size: .55em; line-height: 1.25em;">
int main() {
  CD cd1("Backup", 700);
  MusicCD cd2("Charts", 21);
  cd1.printTitle();
  cout &lt;&lt; cd1.getCapacity() &lt;&lt; endl;
  cd2.printTitle();
  cout &lt;&lt; cd2.getCapacity() &lt;&lt; endl;
  cd2.play();
}
</pre>
</td><td style="border: 0px;">
<div class="console">
> ./cd_class<br />
Backup<br />
700<br />
Charts<br />
21<br />
lalalala
</div>
</td>
</tr></table>
</article></slide>

    <slide><hgroup>
     <h2>Virtuelle Methoden - Problem</h2></hgroup><article>
         <pre class="compact">
int main() 
{
  CD cd1("Backup", 700);
  MusicCD cd2("Charts", 21);
  
  vector&lt;CD*> vec;
  vec.push_back(&amp;cd1);
  vec.push_back(&amp;cd2);
  
  for(auto cd : vec)
  {
    cd->printTitle();
    cout &lt;&lt; cd->getCapacity() &lt;&lt; endl;
  }
}
</pre>
<table width="100%"><tr><td style="border: 0px;" width="10%"><em>Soll</em></td><td style="border: 0px;">
<div class="console" >
Backup<br />
700<br />
Charts<br />
21
</div>
</td>
<td style="border: 0px;">
&nbsp; &nbsp;
</td>
<td style="border: 0px;" width="10%"><em>Ist</em></td>
<td style="border: 0px;">
<div class="console">
Backup<br />
700<br />
Charts<br />
700
</div>
</td>
</tr></table>


         </article></slide>
         <slide><hgroup>
         <h2>Virtuelle Methode - Theorie</h2></hgroup><article>
         <ul>
         <li style="padding-top: 12px;">Schl&uuml;sselwort <span class="src">virtual</span>
         <pre class="compact">virtual int getCapacity() {...}</pre>
         </li>
         <li style="padding-top: 12px;">Es wird zur Laufzeit entschieden, welche Methode aufgerufen wird</li>
         </ul>

         <br /><br />
         <img src="images/homer2.gif" width="100px" style="float: left;"/>
     <div style="border: 1px solid #ccc; border-radius: 16px; padding: 8px; float: left; margin-left: 20px; width: 600px; background-color: #fcfcfc;">
     Destruktoren sollten immer als <span class="src">virtual</span> deklariert sein, damit beim Zerst&ouml;ren des Objekts immer auf den richtigen Destruktor 
     zugegriffen wird.
     </div>
         
    </article></slide>
        <slide><hgroup>
     <h2>Virtual - L&ouml;sung</h2></hgroup><article>
     <br /><br />
     <table style="margin:0px;padding:0px;"><tr><td style="border: 0px;">
<pre class="compact" style="font-size: .55em; line-height: 1.25em; ">
class CD 
{
private:
  int capacity_;
  string title_;
  
public:
  CD(string title, int size) 
   : capacity_(size), title_(title) {}
  
  virtual int getCapacity() { 
    return capacity_; 
  }
  
  void printTitle() { 
    cout &lt;&lt; title_ &lt;&lt; endl; 
  }
};
</pre>
</td><td style="border: 0px;">
<pre class="compact" style="font-size: .55em; line-height: 1.25em;">
class MusicCD : public CD 
{
private:
  int tracks_;

public:
  MusicCD(string name, int tracks) 
   : CD(name, 700), tracks_(tracks)
  {}
  
  int getCapacity() { 
    return tracks_; 
  }
  
  void play() {
    cout &lt;&lt; "lalalala" &lt;&lt; endl;
  }
};
</pre>
</td></tr>
</table>
</article></slide>

<slide><hgroup>
     <h2>Abstrakte Klassen &amp; Rein Virtuelle Methoden</h2></hgroup><article>
         <ul>
          <li>Rein virtuelle Methoden haben keine Funktion:
           <pre>virtual int getCapacity() = 0;</li>
          <li>Enth&auml;lt eine Klasse mindestens eine rein virtuelle Methode, ist sie <em>abstrakt</em></li>
          <li>Die Funktion muss von der abgeleiteten Klasse implementiert werden</li>
          <li>Es k&ouml;nnen keinen Instanzen der Basisklasse (= abstrakten Klasse) erstellt werden</li>
         </ul>
    </article></slide>
    
    <slide><hgroup>
     <h2>Speichermanagement: <span class="src">new</span> und <span class="src">delete</span></h2></hgroup><article>
     
     <table>
      <tr>
       <td style="border: 0px;" ><h4 style="margin-top: 4px;">Speicheranforderung</h4></td><td style="border: 0px;"><h4 style="margin-top: 4px;">Speicherfreigabe</h4></td></tr>
       <tr><td style="border: 0px;">
        <ul>
         <li>Einfache Typen
          <pre class="compact">
int* i = new int;
string* str = new string;
</pre>
         </li>
         <li>Klassen (def. Konstruktor)
          <pre class="compact">
Person* p = new Person;
</pre>
         </li>
         <li>Klassen (mit Konstruktor)
          <pre class="compact">
Person* p = new Person("Max");
</pre>   </li>
         <li>Arrays
          <pre class="compact">
int* a = new int[10];    
</pre>
         </li>
        </ul>
       </td><td style="border: 0px;">
        <ul>
         <li>Einfache Typen
          <pre class="compact">
delete i;
delete str;
</pre>
         </li>
         <li>Klassen (def. Konstruktor)
          <pre class="compact">
delete p;          
</pre>
         </li>
         <li>Klassen (mit Konstruktor)
          <pre class="compact">
delete p;    
</pre>
          </li>
          <li>Arrays
          <pre class="compact">
delete[] a;
</pre>
         </li>
         </ul>
       </td>
      </tr>     
     </table>
    </article></slide>
    

     <slide><hgroup>
       <h2>Einfache Klasse III (ball.h)</h2></hgroup><article>
<pre style="font-size: .55em; line-height: 1.2em; width: 75%; margin: 1em auto;">
#ifndef BALL_H_INCLUDED
#define BALL_H_INCLUDED

#include &lt;string>

class Ball
{
private:
  float x_, y_, speed_;
  int direction_;
  std::string color_;
  std::string name_;

public:
  Ball(float x, float y, float speed, int direction,
       std::string name);
  
  virtual void move() = 0;
  
};

#endif
</pre>
     
     </article></slide>
     
     
     <slide><hgroup>
      <h2><span class="src">NormalBall</span> und <span class="src">CrazyBall</span></h2></hgroup><article>
<pre style="font-size: .6em; line-height: 1.2em; width: 75%; margin: 3em auto;">
#ifndef NORMALBALL_H_INCLUDED
#define NORMALBALL_H_INCLUDED
#include "ball.h"

class NormalBall : public Ball {
  public:
    NormalBall(float x, float y, float speed, int dir,
               std::string name);
    void move();
};
#endif
</pre>
<pre style="font-size: .6em; line-height: 1.2em; width: 75%; margin: 3em auto;">
#ifndef CRAZYBALL_H_INCLUDED
#define CRAZYBALL_H_INCLUDED
#include "ball.h"

class CrazyBall : public Ball {
  public:
    CrazyBall(float x, float y, float speed, int dir, 
              std::string name);
    void move();
};
#endif
</pre>

     </article></slide>
     
     <slide><hgroup>
       <h2>Konstruktor (ball.cpp)</h2></hgroup><article>
<pre style="font-size: .6em; line-height: 1.2em; width: 75%; margin: 4em auto;">
#include &lt;math.h>
#include "ball.h"

Ball::Ball(float x, float y, float speed, int dir, 
      std::string name) : x_(x), y_(y), speed_(speed)
{
  direction_ = dir * M_PI / 180.0;
  name_ = "Ball '" + name + "'";
  color_ = "red";
}

</pre>
     
     </article></slide>
     
     
    <slide><hgroup>
       <h2>Konstruktor (crazyball.cpp / normalball.cpp)</h2></hgroup><article>
<pre style="font-size: .6em; line-height: 1.2em; width: 85%; margin: 4em auto;">
#include &lt;math.h>
#include "ball.h"

Crazyball::Crazyball(float x, float y, float speed, int dir, 
      std::string name) : Ball(x, y, speed, dir, name)
{
  name_ = "CrazyBall '" + name + "'";
  color_ = "blue";
}
</pre>
<pre style="font-size: .6em; line-height: 1.2em; width: 85%; margin: 4em auto;">
#include &lt;math.h>
#include "ball.h"

Normalball::Normalball(float x, float y, float speed, int dir, 
      std::string name) : Ball(x, y, speed, dir, name)
{
}
</pre>
     
     </article></slide>
     
     
     <slide><hgroup>
      <h2><span class="src">move</span> (crazyball.cpp and normalball.cpp)</h2></hgroup><article>
<pre>
void NormalBall::move()
{
  x_ = x_ + cos(direction_) * speed_;
  y_ = y_ + sin(direction_) * speed_;  
  if(x_ &lt; 0 || x_ > 800) 
    direction_ = atan2(sin(direction_), -cos(direction_));
  if(y_ &lt; 0 || y_ > 600)
    direction_ = atan2(-sin(direction_), cos(direction_));
}

void CrazyBall::move()
{
  x_ = x_ + cos(direction_) * speed_ + sin(direction_ / 2) * speed_;
  y_ = y_ + (tan((x_ % 180) * M_PI / 180.0) % 4) * speed_;  
  if(x_ &lt; 0 || x_ > 800) 
    direction_ = atan2(sin(direction_), -cos(direction_));
  if(y_ &lt; 0 || y_ > 600)
    direction_ = atan2(-sin(direction_), cos(direction_));
}

</pre>
     </article></slide>
     

     
     
     <slide><hgroup>
       <h2>Das <code>main</code>-Programm</h2></hgroup><article>
<table style="border: 0px; margin: 4px; padding:0px;"><tr style="border: 0px; margin: 0px; padding:0px;"><td style="border: 0px; margin: 0px; padding:0px;">
<pre class="compact" style="font-size: .55em; line-height: 1.2em; width: 95%;">
#include &lt;vector>
#include "ball.h"

int main()
{
  std::vector&lt;Ball*> balls;

  NormalBall b1(200, 225, 5, 10, "#1");
  balls.push_back(&amp;b1);<div id="balls"></div>
  while(1)
  {
    int i;
    for(i = 0; i &lt; balls.size(); i++)
    {
      balls[i]->move();
    }

    drawWindow(); // some magic...
  }
}

</pre>
</td><td style="border: 0px;">
  <button onclick="Example2.addRandomBall();" class="big_button"><img src="images/add.png" alt="" /> Normalball</button>
  <button onclick="Example2.addRandomCrazyball();" class="big_button"><img src="images/add.png" alt="" /> Crazyball</button>
  <button onclick="Example2.compile();" class="big_button"><img src="images/run.png" alt="" /> Starten</button>
</td></tr></table>

<div id="popup" style="display: none;">

  <div style="position: absolute; left: 80px; top: 80px;">
    <img src="images/window.png" onclick="Example2.kill();"/>
  </div>
  <div style="position: absolute; left: 85px; top: 110px;">
   <canvas id="game" style="width: 700px; height: 430px;"></canvas>
  </div>

</div>
</article></slide>


    <slide><hgroup>
         <h2>C++ 11 Gimmicks &nbsp;  <img src="images/newflag.jpg" style="vertical-align: middle;" /></h2></hgroup><article>
         <ul>
           <li><span class="src">auto</span></li>
           <li>for each</li>
           <li>initializer lists</li>
         </ul>
         <pre style="font-size: 0.6em">
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
  std::vector&lt;int&gt; numbers = {1, 2, 3, 4};
  for(const auto&amp; number : numbers)
  {
    std::cout &lt;&lt; number &lt;&lt; std::endl;
  }
}</pre>
    </article></slide>

    <slide><hgroup>
         <h2>C++ 11 <span class="src">nullptr</span> &nbsp;  <img src="images/newflag.jpg" style="vertical-align: middle;" /></h2></hgroup><article>
         <pre style="font-size: 0.6em">
#include &lt;iostream&gt;

void foo(int number)
{
  std::cout &lt;&lt; "Number: " &lt;&lt; number &lt;&lt; std::endl;
}

void foo(void* pointer)
{
  std::cout &lt;&lt; "Pointer: " &lt;&lt; pointer &lt;&lt; std::endl;
}

int main()
{
  foo(nullptr); // NULL doesn't work!
}</pre>
    </article></slide>

    <slide><hgroup>
         <h2>C++ 11 <span class="src">delete</span> und <span class="src">default</span> &nbsp;  <img src="images/newflag.jpg" style="vertical-align: middle;" /></h2></hgroup><article>
         <pre style="font-size: 0.6em">
class Foo
{
public:
  Foo(Foo&amp; foo) = delete;
  Foo&amp; operator=(Foo&amp; foo) = delete;
  Foo() = default; // keep default constructor
  Foo(double number) {}
  Foo(int number) = delete;
};

int main()
{
  Foo f1; // works, default constructor
  Foo f2 = f1; // doesn't work
  Foo f3(0); // doesn't work either
  Foo f4(3.1415); // works again
}</pre>
    </article></slide>

   <slide><hgroup>
     <h2>Assignment 2</h2></hgroup><article>
         <ul>
         <li>Befehle mit Command Pattern</li>
         </ul>
         <p><strong>Angeforderter Speicher ist in jedem Fall wieder freizugeben</strong></p>
    </article></slide>

    
    <slide><hgroup>
     <h2>Command Pattern</h2></hgroup><article class="no_print">
     
     <img src="images/bulb_off.png" style="position: absolute; top: 70px; left: 8px;" id="cmdBulb" />
     
     <table class="classtable">
      <tr><th>Light</th></tr>
      <tr><td><pre class="syntax" id="cmdOn">void turnOn();</pre>
              <pre class="syntax" id="cmdOff">void turnOff();</pre>
</pre></td></tr>
     </table>
     
          <table class="classtable" style="position: absolute; left: 32px; top: 256px; visibility: hidden;" id="cmdCmd">
      <tr><th>Light<span id="cmdTitle">On</span>Command : Command</th></tr>
      <tr><td><pre class="syntax">int execute(Light&amp; light) {</pre>
<pre class="syntax" id="cmdExCmd">  light.turnOn();</pre><br />
<pre class="syntax">}</pre></td></tr>
     </table>

     <table class="classtable" style="position: absolute; top: 128px; right: 128px;">
      <tr><th>Invoker</th></tr>
      <tr><td><pre id="cmdInv" class="syntax">int invoke(Command&amp; cmd) {
  return cmd.execute(light);<br /> }</pre>
      </td></tr>
     </table>
     
     <div id="cmdCall" style="position: absolute; left: 520px; top: 128px; visibility: hidden;">
      &lt;-
     </div>
     
     <table class="classtable" style="position: absolute; left: 32px; top: 256px;">
      <tr><th>Command</th></tr>
      <tr><td><pre class="syntax">int execute(Light&amp; light) = 0;</pre></td></tr>
     </table>
     
     <img src="images/run.png" style="position: absolute; left: 380px; top: 480px; visibility: hidden;" width="40px" id="cmdRun" onclick="cmdSend();" />

     <br /><br /> <br /><br /><br /><br /><br /> <br /><br /><br />
     <div class="cmdprompt">
      #> <input type="text" id="cmdPrompt" style="border: 0px; background-color: inherit;" onkeypress="return cmdParse(event);" placeholder='(try "light on" or "light off")' />
     </div>

    </article></slide>
    

    <slide><hgroup>
         <h2>Command Pattern</h2></hgroup><article>
         <pre style="font-size: 0.6em;">
class Command
{
  private:
    Command(const Command&amp; original);
    Command&amp; operator=(const Command&amp; original);
    
    std::string command_name_;

  public:
    Command(std::string name);
    virtual ~Command();
        
    virtual int execute(Game&amp; board, std::vector&lt;std::string>&amp; params) = 0;

    const std::string&amp; getName();
};
         </pre>
    </article></slide>
    
        <slide><hgroup>
        <h2>Command Pattern - Beispiel</h2></hgroup><article>
        <pre style="font-size: 0.6em;">
class PrintHello : public Command
{
  public:
    PrintHello() : Command("PrintHello!"){}
    virtual ~PrintHello();
        
    int execute(Game&amp; board, std::vector&lt;std::string>&amp; params);
};

int PrintHello::execute(Game&amp; board, std::vector&lt;std::string>&amp; params)
{
  std::cout &lt;&lt; "Hello" &lt;&lt; std::endl;
}
        </pre>
        </article></slide>


         <slide><hgroup>
     <h2>Befehle</h2></hgroup><article>
     <br />
     
         <div class="command">
          <div class="title">echo</div>
          <div class="text">Gibt beliebig viele übergebene Parameter aus</div>
         </div>

         <div class="command">
          <div class="title">show</div>
          <div class="text">Ausgabe von Spielfeld, Kapital und HP</div>
         </div>
         
         <div class="command">
          <div class="title">list</div>
          <div class="text">Informationen &uuml;ber alle T&uuml;rme und Monster ausgeben</div>
         </div>
         
         <div class="command">
          <div class="title">next</div>
          <div class="text">Runde beenden bzw. <em>n</em> Runden vorspulen</div>
         </div>

         <div class="command">
          <div class="title">quit</div>
          <div class="text">Beendet das Programm</div>
         </div>
         
    </article></slide>
    
<slide class="thank-you-slide segue nobackground">
    <aside class="gdbar right"><img src="images/tugraz128.png"></aside>
    <article class="flexbox vleft auto-fadein">
      <h2>Bis zum nächsten Tutorium!</h2>
    </article></slide>
    </slide>
  <slide class="backdrop"></slide>
</slides>
<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>
